<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Space Colouring Canvas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;           /* White page background */
      touch-action: none;         /* Prevent default scrolling on touch */
    }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 6px;
      max-width: calc(100% - 20px);
      box-sizing: border-box;
      z-index: 10;
    }
    #toolbar * {
      font-family: 'Courier New', monospace;
      color: #fff;
      user-select: none;
    }
    #toolbar label, 
    #toolbar select,
    #toolbar button,
    #toolbar input[type="range"] {
      background: #444;
      border: 2px solid #fff;
      color: #fff;
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      touch-action: none;
      font-size: 0.9em;
    }
    #toolbar input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 80px;
    }
    #toolbar input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }
    #colorPalette {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 200px;
    }
    .swatch {
      width: 20px;
      height: 20px;
      border: 2px solid #fff;
      border-radius: 4px;
      cursor: pointer;
    }
    .swatch.selected {
      outline: 3px solid #fff;
    }
    #loadingIndicator {
      color: #ff0;
      font-size: 0.9em;
      margin-left: 8px;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;     /* White canvas background */
      touch-action: none;   /* Prevent scrolling while drawing */
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <!-- Template dropdown -->
    <label>
      Template
      <select id="templatePicker">
        <option value="">-- choose image --</option>
        <option value="astronaut.png">Astronaut</option>
        <option value="rocket.png">Rocket</option>
        <option value="planet.png">Planet</option>
      </select>
    </label>

    <!-- Loading text (hidden until needed) -->
    <span id="loadingIndicator" style="display: none;">Loading…</span>

    <!-- Tool buttons -->
    <button id="sprayBtn" disabled>Spray</button>
    <button id="brushBtn" disabled>Brush</button>
    <button id="shapeBtn" disabled>Shape</button>
    <button id="fillBtn" disabled>Fill</button>

    <!-- Shape picker -->
    <label>
      Shape
      <select id="shapePicker" disabled>
        <option value="circle">Circle</option>
        <option value="rect">Square</option>
      </select>
    </label>

    <!-- Size slider -->
    <label>
      Size
      <input type="range" id="sizePicker" min="5" max="100" value="30" disabled>
    </label>

    <!-- Color palette -->
    <div id="colorPalette"></div>

    <!-- Clear button -->
    <button id="clearBtn" disabled>Clear</button>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    // --- DOM Elements ---
    const canvas        = document.getElementById('canvas');
    const ctx           = canvas.getContext('2d');
    const tplPicker     = document.getElementById('templatePicker');
    const loadingText   = document.getElementById('loadingIndicator');
    const sprayBtn      = document.getElementById('sprayBtn');
    const brushBtn      = document.getElementById('brushBtn');
    const shapeBtn      = document.getElementById('shapeBtn');
    const fillBtn       = document.getElementById('fillBtn');
    const shapePicker   = document.getElementById('shapePicker');
    const sizePicker    = document.getElementById('sizePicker');
    const colorPalette  = document.getElementById('colorPalette');
    const clearBtn      = document.getElementById('clearBtn');

    // --- State Variables ---
    let tool = 'spray';                // 'spray', 'brush', 'shape', 'fill'
    let isReady = true;                // becomes false while loading an image
    let spraying = false;
    let brushDrawing = false;
    let lastPos = { x: 0, y: 0 };
    let currentColor = '#ff0000';      // default starting color

    // 20-color palette (feel free to tweak any hex values)
    const PALETTE = [
      '#e6194b','#3cb44b','#ffe119','#0082c8','#f58231',
      '#911eb4','#46f0f0','#f032e6','#d2f53c','#fabebe',
      '#008080','#e6beff','#aa6e28','#fffac8','#800000',
      '#aaffc3','#808000','#ffd8b1','#000080','#808080'
    ];

    // --- Resize Canvas to Fit Window ---
    function resizeCanvas() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- Build Color Palette UI ---
    function buildPalette() {
      colorPalette.innerHTML = '';
      PALETTE.forEach((hex, i) => {
        const sw = document.createElement('div');
        sw.classList.add('swatch');
        sw.style.backgroundColor = hex;
        if (hex === currentColor) sw.classList.add('selected');
        sw.addEventListener('click', () => {
          currentColor = hex;
          document.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
          sw.classList.add('selected');
        });
        colorPalette.appendChild(sw);
      });
    }
    buildPalette();

    // --- Enable or Disable All Tools ---
    function setToolsEnabled(enabled) {
      [sprayBtn, brushBtn, shapeBtn, fillBtn, shapePicker, sizePicker, clearBtn]
        .forEach(el => el.disabled = !enabled);
      // Also disable palette clicks if not ready
      document.querySelectorAll('.swatch').forEach(s => s.style.pointerEvents = enabled ? 'auto' : 'none');
    }

    // --- Switch Tool ---
    function setTool(t) {
      tool = t;
    }

    // --- Template Loading Logic ---
    tplPicker.addEventListener('change', () => {
      const src = tplPicker.value;
      if (!src) {
        // If user chooses “-- choose image --”, just clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      // Show loading, disable tools
      isReady = false;
      loadingText.style.display = 'inline';
      setToolsEnabled(false);

      const img = new Image();
      img.onload = () => {
        // Fit image while preserving aspect ratio
        const cw = canvas.width, ch = canvas.height;
        const iw = img.width, ih = img.height;
        const scale = Math.min(cw / iw, ch / ih);
        const dw = iw * scale, dh = ih * scale;
        const dx = (cw - dw) / 2, dy = (ch - dh) / 2;

        // Clear then draw
        ctx.clearRect(0, 0, cw, ch);
        ctx.drawImage(img, dx, dy, dw, dh);

        // Small delay to ensure drawing is fully flushed
        setTimeout(() => {
          isReady = true;
          loadingText.style.display = 'none';
          setToolsEnabled(true);
        }, 100);
      };
      img.onerror = () => {
        console.warn('Failed to load template:', src);
        loadingText.textContent = 'Error loading image';
        setTimeout(() => {
          loadingText.style.display = 'none';
          setToolsEnabled(true);
        }, 1000);
      };
      img.src = src;
    });

    // --- Helper: Get Pointer Position Relative to Canvas ---
    function getPointerPos(e) {
      // clientX and clientY map directly onto canvas, since it fills the window
      return { x: e.clientX, y: e.clientY };
    }

    // --- SPRAY Tool Implementation ---
    function startSpray(e) {
      e.preventDefault();
      if (!isReady) return;
      lastPos = getPointerPos(e);
      spraying = true;
      sprayOnce();
      window.sprayInt = setInterval(sprayOnce, 50);
    }
    function sprayOnce() {
      if (!spraying) return;
      const r = parseInt(sizePicker.value, 10);
      ctx.fillStyle = currentColor;
      const dotCount = Math.floor(r * 0.5);
      for (let i = 0; i < dotCount; i++) {
        const dx = (Math.random() * 2 * r) - r;
        const dy = (Math.random() * 2 * r) - r;
        if (dx * dx + dy * dy <= r * r) {
          ctx.fillRect(lastPos.x + dx, lastPos.y + dy, 2, 2);
        }
      }
    }

    // --- BRUSH Tool Implementation ---
    function startBrush(e) {
      e.preventDefault();
      if (!isReady) return;
      brushDrawing = true;
      const p = getPointerPos(e);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
    }
    function brushMove(e) {
      if (!brushDrawing || !isReady) return;
      e.preventDefault();
      const p = getPointerPos(e);
      ctx.strokeStyle = currentColor;
      ctx.lineWidth = parseInt(sizePicker.value, 10);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }

    // --- SHAPE Tool Implementation ---
    function drawShape(e) {
      e.preventDefault();
      if (!isReady) return;
      const p = getPointerPos(e);
      const s = parseInt(sizePicker.value, 10);
      ctx.fillStyle = currentColor;
      if (shapePicker.value === 'circle') {
        ctx.beginPath();
        ctx.arc(p.x, p.y, s, 0, 2 * Math.PI);
        ctx.fill();
      } else {
        ctx.fillRect(p.x - s/2, p.y - s/2, s, s);
      }
    }

    // --- FILL Tool (Flood-Fill) Implementation ---
    function floodFill(x, y) {
      if (!isReady) return;
      const w = canvas.width, h = canvas.height;
      const imgData = ctx.getImageData(0, 0, w, h);
      const d = imgData.data;
      const px = Math.floor(x), py = Math.floor(y);
      if (px < 0 || px >= w || py < 0 || py >= h) return;

      const idx = (py * w + px) * 4;
      const targetR = d[idx], targetG = d[idx+1], targetB = d[idx+2], targetA = d[idx+3];
      const fillCol = hexToRgba(currentColor);

      // If clicked pixel is already the fill color, do nothing
      if (
        targetR === fillCol.r &&
        targetG === fillCol.g &&
        targetB === fillCol.b &&
        targetA === fillCol.a
      ) {
        return;
      }

      const stack = [[px, py]];
      while (stack.length) {
        const [cx, cy] = stack.pop();
        if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
        const i = (cy * w + cx) * 4;
        if (
          d[i]   === targetR &&
          d[i+1] === targetG &&
          d[i+2] === targetB &&
          d[i+3] === targetA
        ) {
          d[i]   = fillCol.r;
          d[i+1] = fillCol.g;
          d[i+2] = fillCol.b;
          d[i+3] = fillCol.a;
          stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
        }
      }
      ctx.putImageData(imgData, 0, 0);
    }
    function hexToRgba(hex) {
      const val = parseInt(hex.slice(1), 16);
      return {
        r: (val >> 16) & 0xFF,
        g: (val >> 8)  & 0xFF,
        b: (val      ) & 0xFF,
        a: 255
      };
    }

    // --- Pointer Event Handlers ---
    function onPointerDown(e) {
      if (!isReady) return;
      switch (tool) {
        case 'spray':  return startSpray(e);
        case 'brush':  return startBrush(e);
        case 'shape':  return drawShape(e);
        case 'fill':   return floodFill(e.clientX, e.clientY);
      }
    }
    function onPointerMove(e) {
      if (!isReady) return;
      lastPos = getPointerPos(e);
      if (tool === 'spray' && spraying) {
        // update lastPos for continuous spray
      } else if (tool === 'brush' && brushDrawing) {
        brushMove(e);
      }
    }
    function onPointerUp(e) {
      spraying = false;
      brushDrawing = false;
      clearInterval(window.sprayInt);
    }
    function onPointerLeave(e) {
      spraying = false;
      brushDrawing = false;
      clearInterval(window.sprayInt);
    }

    canvas.addEventListener('pointerdown', onPointerDown);
    canvas.addEventListener('pointermove', onPointerMove);
    canvas.addEventListener('pointerup', onPointerUp);
    canvas.addEventListener('pointerleave', onPointerLeave);

    // --- Clear Button ---
    clearBtn.addEventListener('click', () => {
      if (!isReady) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // --- Enable Palette Clicks / Tool Buttons Once DOM is Ready ---
    window.addEventListener('load', () => {
      setToolsEnabled(true);
    });
  </script>
</body>
</html>
